#Neurogranin Peptide Work
library(ggplot2)
library(plyr)
library(dplyr)
library(xlsx)
library(compare)



pep = read.csv(file = "data/NgKD_Protein_Peptide_Comparison_091416.csv")
#prot = read.csv(file = "Neurogranin_KD_it2_Proteome_ModTOutput_030816.csv")


############
#
# The functions listed below are involved with parsing the Proteinpeptidecomparison report generated by Spectrum Mill which will 
# then be processed and transformed into the Cyber T test input.
#
##################


pepFilter = function(pepdf,species = "MOUSE"){
  # Takes a protein peptide comparison dataframe and filters it by species and ensured that each peptide has at least one PSM. 
  #
  #   Input: 
  #        pepdf = Protein peptide comparison dataframe in the .csv format.
  #        species = species to filter the dataframe by.
  #   Output: 
  #        pepdf.filter = Filtered protein peptide comparison dataframe.
  
  pepdf.filter = pepdf[which(pepdf$species == species),]
  numratio_index = grep("_numRatios_",names(pepdf.filter))
  
  for( x in length(numratio_index)){
    pepdf.filter = pepdf.filter[which(pepdf.filter[[numratio_index[x]]] >= 1),]
  }
  
  return(pepdf.filter)
}


pepSeqFix = function(pepdf){
  
  # Takes the species and numRatio filtered proteinpeptidecomparison dataframe and generates a column "seqeunce_capital" which is just
  # a capitalized column of sequences, "sequence_length" which is the length of the sequence, and "seqeunce_charge_groupNum" which
  # will be used as the unique ID column.
  #
  # cyber T input 
  #   Input: 
  #      pepdf = Filtered peptide protein comparison dataframe 
  #   Output:
  #      pepdf = The original pepdf input with the three extra columns added to it. 
  
  
  pep.seq = grep("^sequence$",names(pepdf)) # Finds the sequence column
  pepdf$sequence_capital = toupper(as.character(pepdf[[pep.seq]])) #Turns the sequence column into all capital letters
  pepdf$sequence_length = nchar(as.character(pepdf[[pep.seq]])) #generates the sequence length
  pepdf$sequence_charge_groupnum = paste(pepdf$sequence_capital,"_",pepdf$z,"_",pepdf$protein_group_num,sep="") # Takes the uppercase sequence and the parent charge
  return(pepdf)
}


pepProteinRollupInput = function(pep, seq = TRUE){
  
  # Takes the peptide report with the newly created unqiue identifier and then it makes a smaller dataframe which will then be used
  # for the protein roll up based on the unique identifier.
  #   Input:
  #     pep = cleaned peptide dataframe with the unique ID column of sequence_chargestate_groupnum
  #   Output:
  #     pep.parsed = shortened peptide dataframe. 
  
  
  if(seq == TRUE ){
  index = grep("^sequence_capital$|^accession_number$|^sequence_charge_groupnum$|^score$|^TMT_126_total$|^TMT_127_total$|^TMT_128_total$|^TMT_129_total$|^TMT_130_total$|^TMT_131_total$|^deltaForwardReverseScore$|
             |^sequence_length$|^delta_parent_mass$",names(pep))
  } else {
  index = grep("^accession_number$|^score$|^TMT_126_total$|^TMT_127_total$|^TMT_128_total$|^TMT_129_total$|^TMT_130_total$|^TMT_131_total$|^deltaForwardReverseScore$|
             |^sequence_length$|^delta_parent_mass$",names(pep))
  }
  pep.parsed = pep[,index]
  pep.parsed = pep.parsed[complete.cases(pep.parsed),]
  return(pep.parsed)
}




pepProteinRollup = function(pepdf.parsed){
  
  # Takes the clean peptide dataframe with the unqiue identifier column and all of the other columns as 
  # integers and create a  dataframe which takes the mean value of the raw reporter ion intensity for a given 
  # protein based on the on the peptides. It also gives the standard deviation of those values
  # a filtereing step is applied and any protein that has less than 2 peptides will be removed from the dataframe.
  #   Input:
  #      pepdf.parsed = shortened cleaned peptide dataframe with single unique identifier
  #   Output:
  #     pep.summary.filter = summary report of the rolled up protein list for the peptides
        
 
pep.summary = ddply(pepdf.parsed, .(accession_number), summarize, freq = length(accession_number),
                    score_mean = signif(mean(score),3), score_sd = signif(sd(score),3),
                    TMT_126_mean = signif(mean(TMT_126_total),3),TMT_126_sd = signif(sd(TMT_126_total),3),
                    TMT_127_mean = signif(mean(TMT_127_total),3),TMT_127_sd = signif(sd(TMT_127_total),3),
                    TMT_128_mean = signif(mean(TMT_128_total),3),TMT_128_sd = signif(sd(TMT_128_total),3),
                    TMT_129_mean = signif(mean(TMT_129_total),3),TMT_126_sd = signif(sd(TMT_129_total),3),
                    TMT_130_mean = signif(mean(TMT_130_total),3),TMT_130_sd = signif(sd(TMT_130_total),3),
                    TMT_131_mean = signif(mean(TMT_131_total),3),TMT_131_sd = signif(sd(TMT_131_total),3),
                    delta_parent_mass_mean = signif(mean(delta_parent_mass),3),delta_parent_mass_sd = signif(sd(delta_parent_mass),3),
                    deltaForwardReverseScore_mean = signif(mean(deltaForwardReverseScore),3),deltaForwardReverseScore_mean = signif(sd(deltaForwardReverseScore),3),
                    sequence_length = signif(mean(sequence_length),3), sequence_length_sd = signif(sd(sequence_length),3))
pep.summary.filter = pep.summary[which(pep.summary$freq >=2),]
return(pep.summary.filter)

}


#############################################################################################################
#
#
#Functions that work with the cyberT output and characterization of significant peptides
#
#
#############################################################################################################


c.Out = read.delim(file = "data/NgKD_Cyber_T_test_Results_061316.txt")
colnames(c.Out)[1] = "id"
c.Key = read.delim(file = "data/NgKD_CyberT_Peptide_Input_Key_061316.txt")
c.input = read.delim(file = "data/NgKD_CyberT_Peptide_Input_061316.txt")



cyberTMerge = function(cyT.output,cyT.key){
  
  # Takes CyberT output and then merges it with the cyberT key which contains the peptide accession number and the entry_name
  # Input:
  #   cyT.output = The output of the CyberT test
  #   cyT.key = They Cyber T test key which has the entry name,accession number, and unique peptide id.
  # Output:
  #   cyT.merge = merged cyberT output with the key that give it the accession number and entry name
  
  colnames(cyT.output)[1] == "id"
  cyT.merge = merge(cyT.output,cyT.key, by = "id")
  return(cyT.merge)
  
}



cyberTSignif = function(cyT.merge, FDR = 0.01){
  
  # Takes the merged cyberT output dataframe and adds a boolian variable column of significance based on the FDR defined in the input.
  # Input:
  #    cyT.merge = merged cyberT output with the key
  #    FDR = cutoff for significance
  # Output:
  #   cyT.Merge = merged cyber T output with an added column denoting significance.   
  
  cyT.merge$significant = ifelse(cyT.merge$BH < FDR,1,0)
  return(cyT.merge)
}


cyberTReport = function(cyT.merge,cyT.key){
  
  # Takes the cyberT output that was merged with the key, and then the key was used to get the unique accession numbers. 
  #   Input:
  #      cyT.merge = merged Cybeer T output 
  #      cyT..key = the cyberT key that has the entry name and the accession numner
  #   Output: 
  #     pep.summary = generates a dataframe rolled up by protein that shows 
  
  
  key = unique(cyT.key[,grep("accession_number|entry",names(cyT.key))])
  
  pep.summary = ddply(cyT.merge, .(accession_number), summarize, freq = length(accession_number),
                      signif_peps = sum(significant), signif_percent = signif((signif_peps/freq)*100,3),
                      median_fold_Change = signif(median(fold),3))
  pep.summary = merge(pep.summary,key,by = "accession_number")
  
  return(pep.summary)                   
}



############################################################################################
#This section involves working directly with the cyber T input which has the raw intensities
#For each of the peptides
###########################################################################################



cyberTPepSummaryStats = function(cyT.input){
  
  # Takes the cyberT input and then generates summary statistics based on the intensity of each individual peptide.
  #
  # Input: 
  #  cyT.input = cyberT input with the raw intensites. It is important that the columns are formatted that
  #  the experimental columns are denoted with an e and the control columns are denoted with a c
  # Output: 
  #  cyT.input =the cyberT input with raw intensities for each peptide, with the additional columns
  #  providing information about average values as well as standard deviation. 
  
  
  #Grab the index for the Control & Experimental columns
  control_index = grep("C",names(cyT.input))
  exp_index = grep("E",names(cyT.input))
  

  #Make all of the new columsn
  cyT.input$avg_c = rowMeans(cyT.input[,control_index],na.rm = TRUE) # Mean control intensity
  cyT.input$avg_c_sd = apply(cyT.input[,control_index],1,sd) # Mean control intensity standard deviation
  cyT.input$avg_e = rowMeans(cyT.input[,exp_index],na.rm = TRUE) #Mean experimental intensity 
  cyT.input$avg_e_sd = apply(cyT.input[,exp_index],1,sd) #Mean experimental standard deviation
  cyT.input$cv_e = signif((cyT.input$avg_e_sd / cyT.input$avg_e) * 100,3) # Correlation of variation of the mean experimental intensity 
  cyT.input$cv_c = signif((cyT.input$avg_c_sd / cyT.input$avg_c) * 100,3) # CV oof control average intensity
  cyT.input$ratio = cyT.input$avg_e/ cyT.input$avg_c #ratio of the average experimental intensity/ Control
  cyT.input$ratio_sd = cyT.input$ratio*sqrt((cyT.input$avg_c_sd/cyT.input$avg_c)^2 + (cyT.input$avg_e_sd/cyT.input$avg_e)^2) # SD of the ratio 
                       # of the experimental over control.
  
  return(cyT.input)
}


cyberTPepRatio = function(cyT.input, cyT.key){
  
  # Takes cyberT input with the intnsity summary statistics from the above function and rolls all of the peptides into proteins and 
  # creates an average and a median ratio.
  #
  # Input: cyT.input = CyberT input with intensity summary statistics generated by the function "cyberTPepSummaryStats"
  #
  # Output: cyT.input -> cyT.input with summary statistics
  
  key = unique(cyT.key[,grep("accession",names(cyT.key))])
  cyT.merge = merge(cyT.input, cyT.key, by = "id")
  cyT.merge = cyT.merge[,-(grep("entry",names(cyT.merge)))]
  
  pep.summary2 = ddply(cyT.merge, .(accession_number), summarize, freq = length(accession_number),
                      log2_median_ratio = signif(log(median(ratio),2),3),
                      log2_average_ratio = signif(log(mean(ratio),2),3),
                      linear_median_ratio = signif(median(ratio),3),
                      inear_average_ratio = signif(mean(ratio),3))


#  pep.summary2 = merge(pep.summary2,cyT.key,by = "accession_number")
  return(pep.summary2)
}


cyberTProteinRatio = function(cyT.input,cyT.key){
  pepsum = cyberTPepSummary(cyT.input)
  protRatio = cyberTProteinRatio(pepsum,cyT.key)
  
  return(protRatio)
  
}

















############################################################################################
# Extra Stuff
###########################################################################################

modT.Prot = read.csv(file = "Neurogranin_KD_it2_Proteome_ModTOutput_030816.csv")

overlap = modT.Prot[which(modT.Prot$Accession.Number %in% signif.prot$accession_number),]

overlap = merge(overlap,signif.prot, by = "accession_number")

signif.ModT = modT.Prot[which(modT.Prot$adj.P.Val < 0.01),]

signif.ModT.Overlap = c.report[which(c.report$accession_number %in% signif.ModT$Accession.Number),]

# cyberTReportPrint = function(pep.summary,name = "CyberTReportPrint"){
#   #Input: pep.summary -> Cyber T report peptide summary, which uses the significant peptide column
#   #Output: Excel doclument that has all of the different percentages.
#   #
#   
#   greater.50 = pep.summary[which(pep.summary$signif_percent >= 50),]
#   greater.60 = pep.summary[which(pep.summary$signif_percent >= 60),]
#   greater.70 = pep.summary[which(pep.summary$signif_percent >= 70),]
#   greater.80 = pep.summary[which(pep.summary$signif_percent >= 80),]
#   greater.90 = pep.summary[which(pep.summary$signif_percent >= 90),]
#   
#   wb = createWorkbook(type ="xlsx")
#   g.50 = createSheet(wb=wb , sheetName =">_50%_Signif_Pep")
#   g.60 = createSheet(wb=wb , sheetName =">_60%_Signif_Pep")
#   g.70 = createSheet(wb=wb , sheetName =">_70%_Signif_Pep")
#   g.80 = createSheet(wb=wb , sheetName =">_80%_Signif_Pep")
#   g.90 = createSheet(wb=wb , sheetName =">_90%_Signif_Pep")
#   
#   addDataFrame(x = greater.50, sheet=g.50, row.names = FALSE)
#   addDataFrame(x = greater.60, sheet=g.60, row.names = FALSE)
#   addDataFrame(x = greater.70, sheet=g.70, row.names = FALSE)
#   addDataFrame(x = greater.80, sheet=g.80, row.names = FALSE)
#   addDataFrame(x = greater.90, sheet=g.90, row.names = FALSE)
#   
#   saved.file = paste(name,".xlsx",sep = "")
#   saveWorkbook(wb,saved.file)
# }
# 
# 
# cyberTSignificantExcelReport = function(cyT.output,cyT.key,name = "CyberTReportPrint",FDR = 0.01){
#   #This function just takes the cyberT output and the key and then it determines 
#   # The amount of singificant peptides, and generates an excel report.
# 
#   cyberT.Merged = cyberTMerge(cyT.output = cyT.output,cyT.key = cyT.key)
#   cyberT.Significant = cyberTSignif(cyT.merge = cyberT.Merged,FDR = 0.01)
#   cyberT.Report = cyberTReport(cyT.merge = cyberT.Significant, cyT.key = cyT.key)
#   cyberT.Report.Print = cyberTReportPrint(pep.summary = cyberT.Report,name = name)
#   
# }
# 



#This ddply function with the following example is a good way of 
#breaking the dataset down into accession numbers
#It is important to note that the "summarize" I added in there takes the dataframe
#and returns a condensed version (the one where it combines all of the things that we want together)
#If i wanted just 


pep.summary = ddply(pep, .(accession_number), summarize, freq = length(accession_number),
             score_mean = signif(mean(score),3), score_sd = signif(sd(score),3),
             TMT_126_mean = signif(mean(TMT_126),3),TMT_126_sd = signif(sd(TMT_126),3),
             TMT_127_mean = signif(mean(TMT_127),3),TMT_127_sd = signif(sd(TMT_127),3),
             TMT_128_mean = signif(mean(TMT_128),3),TMT_128_sd = signif(sd(TMT_128),3),
             TMT_129_mean = signif(mean(TMT_129),3),TMT_126_sd = signif(sd(TMT_129),3),
             TMT_130_mean = signif(mean(TMT_130),3),TMT_130_sd = signif(sd(TMT_130),3),
             TMT_131_mean = signif(mean(TMT_131),3),TMT_131_sd = signif(sd(TMT_131),3),
             delta_parent_mass_mean = signif(mean(delta_parent_mass),3),delta_parent_mass_sd = signif(sd(delta_parent_mass),3),
             deltaForwardReverseScore_mean = signif(mean(deltaForwardReverseScore),3),deltaForwardReverseScore_mean = signif(sd(deltaForwardReverseScore),3))
#             sequence_length = signif(mean(sequence_length),3), sequence_length_sd = signif(sd(sequence_length),3))



#Finding Missing Values 

'%nin%' = Negate('%in%')

list50 = signif_prot[which(signif_prot$accession_number %nin% greater.50$accession_number ),]
list50.prot = cynew[which(cynew$accession_number %in% list50$accession_number),]

list60 = signif_prot[which(signif_prot$accession_number %nin% greater.60$accession_number ),]
list60.prot = cynew[which(cynew$accession_number %in% list60$accession_number),]

list70 = signif_prot[which(signif_prot$accession_number %nin% greater.70$accession_number ),]
list70.prot = cynew[which(cynew$accession_number %in% list70$accession_number),]

list80 = signif_prot[which(signif_prot$accession_number %nin% greater.80$accession_number ),]
list80.prot = cynew[which(cynew$accession_number %in% list80$accession_number),]

list90 = signif_prot[which(signif_prot$accession_number %nin% greater.90$accession_number ),]
list90.prot = cynew[which(cynew$accession_number %in% list90$accession_number),]

wb = createWorkbook(type ="xlsx")
g.50 = createSheet(wb=wb , sheetName ="Not_in_>_50%_Signif_Pep")
g.60 = createSheet(wb=wb , sheetName ="Not_in_>_60%_Signif_Pep")
g.70 = createSheet(wb=wb , sheetName ="Not_in_>_70%_Signif_Pep")
g.80 = createSheet(wb=wb , sheetName ="Not_in_>_80%_Signif_Pep")
g.90 = createSheet(wb=wb , sheetName ="Not_in_>_90%_Signif_Pep")

addDataFrame(x = list50.prot, sheet=g.50, row.names = FALSE)
addDataFrame(x = list60.prot, sheet=g.60, row.names = FALSE)
addDataFrame(x = list70.prot, sheet=g.70, row.names = FALSE)
addDataFrame(x = list80.prot, sheet=g.80, row.names = FALSE)
addDataFrame(x = list90.prot, sheet=g.90, row.names = FALSE)




